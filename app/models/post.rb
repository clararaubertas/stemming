require 'hpricot'
require 'open-uri'

class Post < ActiveRecord::Base
  include Bloget::Models::Post

  has_attached_file :image,
                    :styles => {  :big => "500x500>",
    :thumb => "150x150>"},
  :storage => :s3,
  :s3_credentials => { 
  :access_key_id => ENV['S3_KEY'],
  :secret_access_key => ENV['S3_SECRET'],
    :bucket => 'media.stemming.org'},
  :path => "post-:id-:style.:extension"


  before_save :update_published_at
  after_save :queue

  acts_as_taggable

  named_scope :has_tags, lambda {  |tags|
    Post.find_options_for_find_tagged_with(tags, :match_all => true)
  }

  named_scope :poster_login_like, lambda { |c| { :joins => ["LEFT OUTER JOIN users ON (users.id = posts.poster_id)"], :conditions => ['LOWER(users.login) LIKE ?', '%' + c.to_s + '%']}}

  named_scope :poster_name_like, lambda { |c| { :joins => ["LEFT OUTER JOIN users ON (users.id = posts.poster_id)"], :conditions => ["LOWER(users.first_name || ' ' || users.last_name) LIKE ?", '%' + c.to_s + '%']}}

  acts_as_textiled :content
  attr_protected :front_page

  def active_users_link
    users = Array.new
    for c in self.comments
      users << c.poster
    end
    users = users.uniq
    users.delete_if { |u| u == self.poster }
    string = '<a class="activeusers" href="/posts/' + self.permalink + '">'
    string += self.title
    string += '</a><br />'
    string += '<span class="activeusers">'
    string += "<img src='#{self.poster.avatar.url(:small)}' alt='' class='activeuserimg' /> "
    for u in users
      string = string + "<img src='#{ u.avatar.url(:verysmall)}' alt='' /></span> "
    end
    return string
  end


  def close_tags(code)
    h1 = { }
    h2 = { }
    code.scan(/\<([^\>\s\/]+)[^\>\/]*?\>/).each {  |t| h1[t[0]] ? h1[t[0]] += 1 : h1[t[0]] = 1 }
    code.scan(/\<\/([^\>\s\/]+)[^\>]*?\>/).each {  |t| h2[t[0]] ? h2[t[0]] += 1 : h2[t[0]] = 1 }
    h1.each { |k,v| 
      unless k == 'p'
        code += "</#{ k}>" * (h1[k] - h2[k].to_i) if h2[k].to_i < v 
      end
      }
    code
  end

  def update_published_at
    if self.published_changed?
      self.published_at = Time.now
    end
  end

  def sanitized_content
    Sanitize.clean(self.content, :elements => ['sup', 'a', 'span', 'b', 'i', 'strong', 'em', 'u', 'ins', 'ul', 'ol', 'li', 'embed', 'p', 'object', 'param', 'img', 'code', 'pre', 'blockquote', 'h3', 'h4', 'h5'], :attributes => { 'img' => ['src', 'alt', 'style', 'class'], 'embed' => ['src', 'type', 'width', 'height'], :object => ['width', 'height'], :param => ['name', 'value'], :p => ['style'], 'a' => ['href', 'title', 'class'] }, :protocols => { 'a' => { 'href' => ['http', 'https', 'mailto', :relative]}})
  end

  def self.paged_find_tagged_with(tags, args = { })
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql
      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)
      paginate(options.merge(:count => {  :select => options[:select].gsub('*', 'id') }))
    end
  end

  def self.per_page
    5
  end

  def destroy_comments
    for c in self.comments
      c.destroy
    end
  end

  def active_date
    self.created_at
  end

  def excerpt
    HTML::FullSanitizer.new.sanitize(self.content).split[0..(49)].join(" ") + (HTML::FullSanitizer.new.sanitize(self.content).split.size > 50 ? " <a href='/posts/#{self.permalink}'>(read more...)</a>" : "")
  end


  def meta
    HTML::FullSanitizer.new.sanitize(self.content).split[0..(69)].join(" ") + '...'
  end

  def longer_excerpt
    close_tags(self.sanitized_content.split[0..(399)].join(" ")) + (self.sanitized_content.split.size > 400 ? " <a href='/posts/#{self.permalink}'>(read more...)</a>" : "")
  end

  def medium_excerpt
    close_tags(self.sanitized_content.split[0..(99)].join(" ")) + (self.sanitized_content.split.size > 100 ? " <a href='/posts/#{self.permalink}'>(read more...)</a>" : "")
  end

  def queue
    self.send_later(:send_trackbacks)
    self.send_later(:create_activities)
  end

  def create_activities
    for u in (self.poster.friends)
      Activity.create(:activity_id => self.id, :activity_type => 'post', :user_id => u.id)
      u.clean_activities
    end
  end

  def send_trackbacks
    if self.published? && !(self.trackbacks_sent?)
      for u in self.trackback_urls
        begin
          t = Trackback.new(self.id)
          t.send(u)
        rescue
        end
      end
      self.update_attribute(:trackbacks_sent, true)
      return true
    else
      return false
    end
  end



  def trackback_urls
    begin
      results = Array.new
      doc = Hpricot(open('http://stemming.org/posts/' + self.permalink))
      doc.search("//div[@class='content']").first.search("//a").each do |l|
        if l.attributes['href'].match("http")
          results << l.attributes['href']
        end
      end
      return results
    rescue
      return []
    end
  end



end
